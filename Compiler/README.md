# Design of the SubTiger Compiler

The source code of the compiler is distributed across the 
following files: -

- ast.sml   : Abstract Syntax Tree
- tiger.grm : Grammer of the Language
- tiger.lex : Lexical Analysis file
- temp.sml  : Helper functions for creating labels and temporaries
- tree.sml  : Contains Structure of Tree Intermediate Representation (IR)
- func.sml  : Helper functions to generate a Function Map Data Structure
- frame.sml : Helper functions to handle stack frame while declaring and
calling functions
- translate.sml     : Translate from abstract syntax tree generated by
parsing the tiger source code to Tree IR
- mips.sml  : Contains Structure for MIPS statements, also
contains helper functions to output the generated MIPS code in the form
of a string.
- codeGen.sml       : Generates MIPS assembly code from the Tree IR
- arg.sml   : Contains function to get input, output and IR file names
from command line arguments
- tiger_driver.sml  : The main code where the execution begins, this
uses the lexer-parser, translator and code generator to generate
MIPS assembly from tiger source code

# Design Choices

We have used the following design choices: -

1. Everything would be organized on the stack, even the variables
that are declared at the top level are organized on the stack
since the top level code is itself is thought to be inside
a function declaration.

2. A function frame is as follows,
    - Previous frame pointer value i.e. the frame pointer value
    of the caller of current function
    - Space for Return address to be stored
    - Static link - the frame pointer of the last call to the
    function in which current function is declared. In other
    words, frame pointer of the last call to the parent of 
    current function
    - Previous stack pointer value i.e. the frame pointer value
    of the caller of current function
    - Arguments of the current function passed by the caller

```
                    |---------------|
    Frame pointer-->|  prev fp val  |
                    |  return addr  |
                    |  static link  |
                    |  prev sp val  |
                    |     arg1      |
                    |     arg2      |
                    |     arg3      |
                    |     ....      |
                    |   Local var   |
    Stack pointer-->|     ....      |
```

3. We allocate the entire space the local variables would
require when we encounter a function declaration. For example,
if the function uses 10 local variables in total, then we allocate
10 * wordSize space in the stack as soon as we enter the function.
Now, this would lead to the stack pointer having allocated more
space than required at the current moment, hence when we call a function
we must store the stack pointer value into the frame of the new function,
so that we can retrieve the stack pointer value.

4. Currenlty, we don't have a register allocation algorithm, hence
most computation stores the value into the stack, retrieves the value
into temporary registers, performs the computation and places the result
into the stack. This causes the compiled program to be somewhat slow.

5. We have built-in functions for printing expression values, they are
`print` and `println` which print the value without or with a newline
respectively.

6. Currenlty, we do not have short-circuiting of `if` statements

7. Our error checking mechanism is quite week as of now

# Restrictions on the Tree Intermediate Code

- BINOP can take only temporaries as input

- All expressions should be of the form Tree.ESEQ (stmt, resultTemp)

- Call can only be used by the **print** and **println** functions
for actual function call, while it can be used by other functions
for just jumping and linking, **we must pass this without arguments**

- We can return the return values in the return value register

- MOVE can happend between mem and temp, temp and mem, temp and
binop applied on temps, temp and const.